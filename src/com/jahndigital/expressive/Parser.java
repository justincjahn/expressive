package com.jahndigital.expressive;

import java.util.ArrayList;

/**
 * Parses tokens generated by the lexer into a series of expressions that form an Abstract Syntax Tree (AST)
 */
final class Parser {
    private final ArrayList<String> _errors = new ArrayList<>();
    private final ArrayList<SyntaxToken> _tokens = new ArrayList<>();
    private int _position = 0;

    /**
     * Gets a list of errors the lexer or parser has encountered.
     */
    public Iterable<String> getErrors() {
        return _errors;
    }

    /**
     * Init
     *
     * @param text The expression to lex and parse.
     */
    public Parser(String text) {
        Lexer lexer = new Lexer(text);
        SyntaxToken token;

        do {
            token = lexer.NextToken();

            if (token.getKind() != SyntaxKind.WhitespaceToken &&
                    token.getKind() != SyntaxKind.BadToken) {
                _tokens.add(token);
            }
        } while (token.getKind() != SyntaxKind.EndOfFileToken);

        lexer.getErrors().forEach(_errors::add);
    }

    /**
     * Look ahead in the token list by the provided offset.
     *
     * @param offset The offset from the current position to peek ahead.
     * @return The token at position + offset, or the last token.
     */
    private SyntaxToken peek(int offset) {
        int index = _position + offset;

        if (index > _tokens.size()) {
            return _tokens.get(_tokens.size() - 1);
        }

        return _tokens.get(index);
    }

    /**
     * Get the token at the current position.
     */
    private SyntaxToken getCurrent() {
        return peek(0);
    }

    /**
     * Returns the token at the current position and moves the position ahead by one.
     */
    private SyntaxToken nextToken() {
        SyntaxToken current = getCurrent();
        _position++;
        return current;
    }

    /**
     * Returns current token if it matches the provided SyntaxKind, or generates a new token of Kind and logs an error.
     *
     * @param kind The SyntaxKind to expect.
     * @return The token, if matched, or a "generated" token.
     */
    private SyntaxToken matchToken(SyntaxKind kind) {
        if (getCurrent().getKind() == kind) {
            return nextToken();
        }

        _errors.add(String.format("ERROR: Unexpected token <%s>, expected %s.", getCurrent().getKind(), kind));
        return new SyntaxToken(kind, _position, null, null);
    }

    /**
     * Parse the provided tokens into an AST and return it.
     *
     * @return The root node of a syntax tree.
     */
    public SyntaxTree parse() {
        ExpressionSyntaxNode root = parseExpression();
        SyntaxToken eof = matchToken(SyntaxKind.EndOfFileToken);
        return new SyntaxTree(_errors, root, eof);
    }

    /**
     * Parses an expression and returns it.
     */
    private ExpressionSyntaxNode parseExpression() {
        return parseExpression(0);
    }

    /**
     * Parses an expression, selecting an operator based on its precedence.
     *
     * @param parentPrecedence
     * @return
     */
    private ExpressionSyntaxNode parseExpression(int parentPrecedence)
    {
        ExpressionSyntaxNode left;

        int unaryPrecedence = SyntaxFacts.getUnaryOperatorPrecedence(getCurrent().getKind());
        if (unaryPrecedence != 0 && unaryPrecedence >= parentPrecedence) {
            SyntaxToken operatorToken = nextToken();
            ExpressionSyntaxNode operand = parseExpression(unaryPrecedence);
            left = new UnaryExpressionSyntaxNode(operatorToken, operand);
        } else {
            left = parsePrimary();
        }

        while (true) {
             int precedence = SyntaxFacts.getBinaryOperatorPrecedence(getCurrent().getKind());

             if (precedence == 0 || precedence <= parentPrecedence) {
                 break;
             }

             SyntaxToken operatorToken = nextToken();
             ExpressionSyntaxNode right = parseExpression(precedence);
             left = new BinaryExpressionSyntaxNode(left, operatorToken, right);
        }

        return left;
    }

//    /**
//     * Parses an addition or subtraction operation and returns it.
//     */
//    public ExpressionSyntaxNode parseAddSubtract() {
//        ExpressionSyntaxNode left = parseMultiplyDivide();
//
//        while (getCurrent().getKind() == SyntaxKind.PlusToken ||
//                getCurrent().getKind() == SyntaxKind.MinusToken) {
//            SyntaxToken operatorToken = nextToken();
//            ExpressionSyntaxNode right = parseMultiplyDivide();
//            left = new BinaryExpressionSyntaxNode(left, operatorToken, right);
//        }
//
//        return left;
//    }

//    /**
//     * Parses a multiplication and division operation and returns it.
//     */
//    public ExpressionSyntaxNode parseMultiplyDivide() {
//        ExpressionSyntaxNode left = parsePrimary();
//
//        while (getCurrent().getKind() == SyntaxKind.StarToken ||
//                getCurrent().getKind() == SyntaxKind.SlashToken) {
//            SyntaxToken operatorToken = nextToken();
//            ExpressionSyntaxNode right = parsePrimary();
//            left = new BinaryExpressionSyntaxNode(left, operatorToken, right);
//        }
//
//        return left;
//    }

    /**
     * Parses a literal or parenthesised expression and returns it.
     */
    private ExpressionSyntaxNode parsePrimary() {
        SyntaxKind kind = getCurrent().getKind();
        if (kind == SyntaxKind.OpenParenthesisToken) {
            SyntaxToken left = nextToken();
            ExpressionSyntaxNode expression = parseExpression();
            SyntaxToken right = matchToken(SyntaxKind.CloseParenthesisToken);
            return new ParenthesisedExpressionSyntax(left, expression, right);
        }

        SyntaxToken numberToken = matchToken(SyntaxKind.NumberToken);
        return new LiteralExpressionSyntaxNode(numberToken);
    }
}
