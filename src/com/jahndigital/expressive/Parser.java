package com.jahndigital.expressive;

import java.util.ArrayList;

/**
 * Parses tokens generated by the lexer into a series of expressions that form an Abstract Syntax Tree (AST)
 */
public class Parser {
    private final ArrayList<String> _errors = new ArrayList<>();
    private final ArrayList<SyntaxToken> _tokens = new ArrayList<>();
    private int _position = 0;

    public Iterable<String> getErrors() {
        return _errors;
    }

    public Parser(String text) {
        Lexer lexer = new Lexer(text);
        SyntaxToken token;

        do {
            token = lexer.NextToken();

            if (token.getKind() != SyntaxKind.WhitespaceToken &&
                    token.getKind() != SyntaxKind.BadToken) {
                _tokens.add(token);
            }
        } while (token.getKind() != SyntaxKind.EndOfFileToken);

        // Java is gross, I miss C#
        lexer.getErrors().forEach(_errors::add);
    }

    private SyntaxToken peek(int offset) {
        int index = _position + offset;

        if (index > _tokens.size()) {
            return _tokens.get(_tokens.size() - 1);
        }

        return _tokens.get(index);
    }

    private SyntaxToken getCurrent() {
        return peek(0);
    }

    private SyntaxToken nextToken() {
        SyntaxToken current = getCurrent();
        _position++;
        return current;
    }

    private SyntaxToken match(SyntaxKind kind) {
        if (getCurrent().getKind() == kind) {
            return nextToken();
        }

        _errors.add(String.format("ERROR: Unexpected token <%s>, expected %s.", getCurrent().getKind(), kind));
        return new SyntaxToken(kind, _position, null, null);
    }

    public SyntaxTree parse() {
        ExpressionSyntax root = parseAddSubtract();
        SyntaxToken eof = match(SyntaxKind.EndOfFileToken);
        return new SyntaxTree(_errors, root, eof);
    }

    private ExpressionSyntax parseExpression() {
        return parseAddSubtract();
    }

    public ExpressionSyntax parseAddSubtract() {
        ExpressionSyntax left = parseMultiplyDivide();

        while (getCurrent().getKind() == SyntaxKind.PlusToken ||
                getCurrent().getKind() == SyntaxKind.MinusToken) {
            SyntaxToken operatorToken = nextToken();
            ExpressionSyntax right = parseMultiplyDivide();
            left = new BinaryExpressionSyntax(left, operatorToken, right);
        }

        return left;
    }

    public ExpressionSyntax parseMultiplyDivide() {
        ExpressionSyntax left = parsePrimary();

        while (getCurrent().getKind() == SyntaxKind.StarToken ||
                getCurrent().getKind() == SyntaxKind.SlashToken) {
            SyntaxToken operatorToken = nextToken();
            ExpressionSyntax right = parsePrimary();
            left = new BinaryExpressionSyntax(left, operatorToken, right);
        }

        return left;
    }

    private ExpressionSyntax parsePrimary() {
        SyntaxKind kind = getCurrent().getKind();
        if (kind == SyntaxKind.OpenParenthesisToken) {
            SyntaxToken left = nextToken();
            ExpressionSyntax expression = parseExpression();
            SyntaxToken right = match(SyntaxKind.CloseParenthesisToken);
            return new ParenthesisedExpressionSyntax(left, expression, right);
        }

        SyntaxToken numberToken = match(SyntaxKind.NumberToken);
        return new NumberExpressionSyntax(numberToken);
    }
}
