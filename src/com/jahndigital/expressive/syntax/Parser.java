package com.jahndigital.expressive.syntax;

import com.jahndigital.expressive.DiagnosticRepository;

import java.util.ArrayList;

/**
 * Parses tokens generated by the lexer into a series of expressions that form an Abstract Syntax Tree (AST)
 */
final class Parser
{
    private final DiagnosticRepository _diagnostics;
    private final ArrayList<SyntaxToken> _tokens = new ArrayList<>();
    private int _position = 0;

    /**
     * Init
     *
     * @param text The expression to lex and parse.
     * @param diagnostics The repository to use when reporting issues with lexing.
     */
    Parser(String text, DiagnosticRepository diagnostics)
    {
        _diagnostics = diagnostics;
        Lexer lexer = new Lexer(text, diagnostics);

        SyntaxToken token;
        do {
            token = lexer.nextToken();

            if (token.getKind() != SyntaxKind.WhitespaceToken &&
                    token.getKind() != SyntaxKind.BadToken) {
                _tokens.add(token);
            }
        } while (token.getKind() != SyntaxKind.EndOfFileToken);
    }

    /**
     * Parse the provided tokens into an AST and return it.
     *
     * @return The root node of a syntax tree.
     */
    SyntaxTree parse()
    {
        ExpressionSyntaxNode root = parseExpression();
        SyntaxToken eof = matchToken(SyntaxKind.EndOfFileToken);
        return new SyntaxTree(_diagnostics, root, eof);
    }

    /**
     * Look ahead in the token list by the provided offset.
     *
     * @param offset The offset from the current position to peek ahead.
     * @return The token at position + offset, or the last token.
     */
    private SyntaxToken peek(int offset)
    {
        int index = _position + offset;

        if (index > _tokens.size()) {
            return _tokens.get(_tokens.size() - 1);
        }

        return _tokens.get(index);
    }

    /**
     * Get the token at the current position.
     */
    private SyntaxToken getCurrent()
    {
        return peek(0);
    }

    /**
     * Returns the token at the current position and moves the position ahead by one.
     */
    private SyntaxToken nextToken()
    {
        SyntaxToken current = getCurrent();
        _position++;
        return current;
    }

    /**
     * Returns current token if it matches the provided SyntaxKind, or generates a new token of Kind and logs an error.
     *
     * @param kind The SyntaxKind to expect.
     * @return The token, if matched, or a "generated" token.
     */
    private SyntaxToken matchToken(SyntaxKind kind)
    {
        if (getCurrent().getKind() == kind) {
            return nextToken();
        }

        _diagnostics.addUnexpectedToken(getCurrent(), kind);
        return new SyntaxToken(kind, _position, null, null);
    }

    /**
     * Parses an expression and returns it.
     */
    private ExpressionSyntaxNode parseExpression()
    {
        return parseExpression(0);
    }

    /**
     * Parses an expression, selecting an operator based on its precedence.
     *
     * @param parentPrecedence The weight of the parent.
     * @return The parsed syntax node (recursive into a tree).
     */
    private ExpressionSyntaxNode parseExpression(int parentPrecedence)
    {
        ExpressionSyntaxNode left;

        int unaryPrecedence = SyntaxFacts.getUnaryOperatorPrecedence(getCurrent().getKind());
        if (unaryPrecedence != 0 && unaryPrecedence >= parentPrecedence) {
            SyntaxToken operatorToken = nextToken();
            ExpressionSyntaxNode operand = parseExpression(unaryPrecedence);
            left = new UnaryExpressionSyntaxNode(operatorToken, operand);
        } else {
            left = parsePrimary();
        }

        while (true) {
             int precedence = SyntaxFacts.getBinaryOperatorPrecedence(getCurrent().getKind());

             if (precedence == 0 || precedence <= parentPrecedence) {
                 break;
             }

             SyntaxToken operatorToken = nextToken();
             ExpressionSyntaxNode right = parseExpression(precedence);
             left = new BinaryExpressionSyntaxNode(left, operatorToken, right);
        }

        return left;
    }

    /**
     * Parses a literal or parenthesised expression and returns it.
     */
    private ExpressionSyntaxNode parsePrimary()
    {
        SyntaxKind kind = getCurrent().getKind();

        switch (kind) {
            case OpenParenthesisToken: {
                SyntaxToken left = nextToken();
                ExpressionSyntaxNode expression = parseExpression();
                SyntaxToken right = matchToken(SyntaxKind.CloseParenthesisToken);
                return new ParenthesisedExpressionSyntax(left, expression, right);
            }

            case TrueToken:
            case FalseToken: {
                boolean value = kind == SyntaxKind.TrueToken;
                return new LiteralExpressionSyntaxNode(nextToken(), value);
            }

            default: {
                SyntaxToken numberToken = matchToken(SyntaxKind.NumberToken);
                return new LiteralExpressionSyntaxNode(numberToken);
            }
        }
    }
}
