package com.jahndigital.expressive.syntax;

import com.jahndigital.expressive.DiagnosticRepository;
import com.jahndigital.expressive.FunctionRepository;
import com.jahndigital.expressive.TextSpan;
import com.jahndigital.expressive.extensibility.IFunction;

import java.util.ArrayList;

/**
 * Parses tokens generated by the lexer into a series of expressions that form an Abstract Syntax Tree (AST)
 */
final class Parser
{
    private final DiagnosticRepository _diagnostics;
    private final FunctionRepository _functions;
    private final ArrayList<SyntaxToken> _tokens = new ArrayList<>();
    private int _position = 0;

    /**
     * Init with the default {@link DiagnosticRepository} and {@link FunctionRepository}.
     *
     * @param text The expression to lex and parse.
     */
    Parser(String text)
    {
        this(text, DiagnosticRepository.DefaultDiagnosticRepository);
    }

    /**
     * Init with the default {@link FunctionRepository}
     *
     * @param text The expression to lex and parse.
     * @param diagnostics The repository to use when reporting issues with lexing.
     */
    Parser(String text, DiagnosticRepository diagnostics)
    {
        this(text, diagnostics, FunctionRepository.DefaultFunctionRepository);
    }

    /**
     * Init with a custom {@link FunctionRepository} instead of the default one.
     *
     * @param text The expression to lex and parse.
     * @param diagnostics The repository to use when reporting issues with lexing.
     * @param functions The repository to use when attempting to resolve built-in functions.
     */
    Parser(String text, DiagnosticRepository diagnostics, FunctionRepository functions)
    {
        _diagnostics = diagnostics;
        _functions = functions;
        Lexer lexer = new Lexer(text, diagnostics);

        SyntaxToken token;
        do {
            token = lexer.nextToken();

            if (token.getKind() != SyntaxKind.WhitespaceToken &&
                token.getKind() != SyntaxKind.BadToken) {
                _tokens.add(token);
            }
        } while (token.getKind() != SyntaxKind.EndOfFileToken);
    }

    /**
     * Parse the provided tokens into an AST and return it.
     *
     * @return The root node of a syntax tree.
     */
    SyntaxTree parse()
    {
        _diagnostics.reset();
        ExpressionSyntaxNode root = parseExpression();
        SyntaxToken eof = matchToken(SyntaxKind.EndOfFileToken);
        return new SyntaxTree(_diagnostics, root, eof);
    }

    /**
     * Look ahead in the token list by the provided offset.
     *
     * @param offset The offset from the current position to peek ahead.
     * @return The token at position + offset, or the last token.
     */
    private SyntaxToken peek(int offset)
    {
        int index = _position + offset;

        if (index > _tokens.size()) {
            return _tokens.get(_tokens.size() - 1);
        }

        return _tokens.get(index);
    }

    /**
     * Get the token at the current position.
     */
    private SyntaxToken getCurrent()
    {
        return peek(0);
    }

    /**
     * Returns the token at the current position and moves the position ahead by one.
     */
    private SyntaxToken nextToken()
    {
        SyntaxToken current = getCurrent();
        _position++;
        return current;
    }

    /**
     * Returns current token if it matches the provided SyntaxKind, or generates a new token of Kind and logs an error.
     *
     * @param kind The SyntaxKind to expect.
     * @return The token, if matched, or a "generated" token.
     */
    private SyntaxToken matchToken(SyntaxKind kind)
    {
        if (getCurrent().getKind() == kind) {
            return nextToken();
        }

        _diagnostics.addUnexpectedToken(getCurrent(), kind);
        return new SyntaxToken(kind, _position, null, null);
    }

    /**
     * Parses an expression and returns it.
     */
    private ExpressionSyntaxNode parseExpression()
    {
        return parseExpression(0);
    }

    /**
     * Parses an expression, selecting an operator based on its precedence.
     *
     * @param parentPrecedence The weight of the parent.
     * @return The parsed syntax node (recursive into a tree).
     */
    @SuppressWarnings("InfiniteRecursion")
    private ExpressionSyntaxNode parseExpression(int parentPrecedence)
    {
        ExpressionSyntaxNode left;

        int unaryPrecedence = SyntaxFacts.getUnaryOperatorPrecedence(getCurrent().getKind());
        if (unaryPrecedence != 0 && unaryPrecedence >= parentPrecedence) {
            SyntaxToken operatorToken = nextToken();
            ExpressionSyntaxNode operand = parseExpression(unaryPrecedence);
            left = new UnaryExpressionSyntaxNode(operatorToken, operand);
        } else {
            left = parsePrimary();
        }

        while (true) {
             int precedence = SyntaxFacts.getBinaryOperatorPrecedence(getCurrent().getKind());

             if (precedence == 0 || precedence <= parentPrecedence) {
                 break;
             }

             SyntaxToken operatorToken = nextToken();
             ExpressionSyntaxNode right = parseExpression(precedence);
             left = new BinaryExpressionSyntaxNode(left, operatorToken, right);
        }

        return left;
    }

    /**
     * Parses a literal or parenthesised expression and returns it.
     */
    private ExpressionSyntaxNode parsePrimary()
    {
        SyntaxKind kind = getCurrent().getKind();

        switch (kind) {
            case OpenParenthesisToken:
            {
                SyntaxToken left = nextToken();
                ExpressionSyntaxNode expression = parseExpression();
                SyntaxToken right = matchToken(SyntaxKind.CloseParenthesisToken);
                return new ParenthesisedExpressionSyntax(left, expression, right);
            }
            case TrueToken:
            case FalseToken:
            {
                boolean value = kind == SyntaxKind.TrueToken;
                return new LiteralExpressionSyntaxNode(nextToken(), value);
            }
            case KeywordToken:
            {
                return parseFunction();
            }
            default:
            {
                SyntaxToken numberToken = matchToken(SyntaxKind.NumberToken);
                return new LiteralExpressionSyntaxNode(numberToken);
            }
        }
    }

    /**
     * Generate a {@link FunctionExpressionSyntaxNode}, recursively parse arguments, and return it.
     */
    private FunctionExpressionSyntaxNode parseFunction()
    {
        SyntaxToken functionNameToken = nextToken();

        // Attempt to find the function
        IFunction function = null;
        for (IFunction x : _functions) {
            if (x.getName().equalsIgnoreCase(functionNameToken.getText())) {
                function = x;
                break;
            }
        }

        if (function == null) {
            _diagnostics.addUnregisteredFunction(functionNameToken);
        }

        ArrayList<ExpressionSyntaxNode> arguments = new ArrayList<>();
        if (getCurrent().getKind() == SyntaxKind.OpenParenthesisToken) {
            SyntaxToken openArguments = matchToken(SyntaxKind.OpenParenthesisToken);

            while(getCurrent().getKind() != SyntaxKind.CloseParenthesisToken) {
                if (getCurrent().getKind() == SyntaxKind.EndOfFileToken) {
                    _diagnostics.addMissingClosingParentheses(new TextSpan(openArguments.getPosition(), getCurrent().getPosition()));
                    break;
                }

                arguments.add(parseExpression());

                if (getCurrent().getKind() == SyntaxKind.CommaToken) {
                    matchToken(SyntaxKind.CommaToken);
                }
            }

            matchToken(SyntaxKind.CloseParenthesisToken);
        }

        return new FunctionExpressionSyntaxNode(functionNameToken, function, arguments);
    }
}
